<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
	<title>webVR-particles</title>
	<style>
		* {
			padding: 0;
			margin: 0;
		}
		html,body {
			height: 100%;
		}
		body {
			overflow-y: hidden;
		}
	</style>
</head>
<body>
</body>
<script src="./vendor/three.min.js"></script>
<script src="./vendor/OrbitControls.js"></script>
<script src="./vendor/tween.min.js"></script>
<script type="text/javascript">/**
** author:YorkChan
** date:2016-12-18
**/
class Page {
	constructor() {
		this.scene = new THREE.Scene();
		this.camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,10000);
		this.camera.position.set(0,20,100);
		this.camera.lookAt(new THREE.Vector3(0,0,0));
		this.scene.add(this.camera);
		this.renderer = new THREE.WebGLRenderer({
			antialias: true
		});
		this.renderer.setSize(window.innerWidth,window.innerHeight);
		this.renderer.setClearColor(0x111111);
		this.controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
		document.body.appendChild(this.renderer.domElement);
		this.resize();
		this.start();
		this.render();
	}
	resize() {
		window.addEventListener('resize',e => {
			this.camera.aspect = window.innerWidth/window.innerHeight;
			this.camera.updateProjectionMatrix();
			this.renderer.setSize(window.innerWidth,window.innerHeight);
		});
	}
	render() {
		let render = () => {
			this.update();
			this.renderer.render(this.scene,this.camera);
			requestAnimationFrame(render);
		}
		render();
	}
	async animateShow() {
		this.transform(this.particles.geometry,4000,'json','./assets/WaltHeadLo.js');
		await Page.sleep(8000);
		this.transform(this.particles.geometry,4000,'torus');
		await Page.sleep(8000);
		this.transform(this.particles.geometry,4000,'cone');
		await Page.sleep(8000);
		this.transform(this.particles.geometry,4000,'sphere');
		await Page.sleep(8000);
	}
	start() {
		this.createLight();
		this.particles = this.createParticles(1600,1.5,50);
			this.animateShow();
		setInterval(() => {
			this.animateShow();
		},32000)
	}
	async transform(orginGeo,duration,type,path) {
		const TYPE = {
			CUBE: 'cube',
			SPHERE: 'sphere',
			CONE: 'cone',
			CYLINDER: 'cylinder',
			TORUS : 'torus',
			JSON : 'json'
		};
		TWEEN.removeAll();
		let points = orginGeo.vertices;
		const n = Math.sqrt(points.length);
		// let geometry = new THREE.SphereGeometry(20,50,50);
		let geometry;
		switch(type) {
			case TYPE.SPHERE : geometry = new THREE.SphereGeometry(20,n,n);break;
			case TYPE.CONE : geometry = new THREE.ConeGeometry(20,15,n,n);break;
			case TYPE.CYLINDER : geometry = new THREE.CylinderGeometry( 8, 8, 20, n,n );break;
			case TYPE.TORUS : geometry = new THREE.TorusGeometry( 15, 8, n, n );break;
			case TYPE.JSON: {
				geometry = await Page.getModel(path);
			};break;
		}
		
		for(let i in points) {
			new TWEEN.Tween(points[i])
						.to(geometry.vertices[i],duration)
						.onUpdate(() => {
							orginGeo.verticesNeedUpdate = true;
						})
						.start();
		}
		let originColor = this.material.color;
		new TWEEN.Tween(originColor)
					.to({r:Math.random(),g:Math.random(),b:Math.random()})
					.onUpdate(() => {
						this.material.color.set( this.r,this.g,this.b );
					})
					.start();
	}
	update() {
		TWEEN.update();
	}
	static getModel(path) {
		return new Promise(resolve => {
			let loader = new THREE.JSONLoader();
			loader.load(path,geometry => {
				resolve(geometry);
			})
		})
	}
	static sleep(time) {
		return new Promise(resolve => {
			setTimeout(() => {
				resolve();
			},time);
		})
	}
	createParticles(num,size,area) {
		let drawArc = function() {
			// 创建画布
			var canvas = document.createElement('canvas');
			canvas.width	= 100;
			canvas.height	= 100;
			var ctx = canvas.getContext('2d');
			ctx.beginPath();
			ctx.arc(50,50,50, 0 ,2*Math.PI,true);
			ctx.fillStyle = "#ffffff";
			ctx.fill();
			return canvas;
		};
		let texture = new THREE.Texture(drawArc());
		texture.needsUpdate	= true;
		let geometry = new THREE.Geometry();
		for (let i = 0; i < num; i ++ ) {

			let vertex = new THREE.Vector3();
			vertex.x = Math.random() * area - area/2;
			vertex.y = Math.random() * area - area/2;
			vertex.z = Math.random() * area - area/2;

			geometry.vertices.push( vertex );

		}
		this.material = new THREE.PointsMaterial( { size: size,color: 0xffffff ,sizeAttenuation:false, transparent: true } );
		let particles = new THREE.Points(geometry,this.material);
		this.scene.add(particles);
		return particles;
	}
	createLight() {
		// 创建光线
        this.scene.add(new THREE.AmbientLight(0xFFFFFF));
        let light = new THREE.DirectionalLight( 0xffffff, 0.3 );
		light.position.set( 50, 50, 50 );
		light.castShadow = true;
		light.shadow.mapSize.width = 2048;
		light.shadow.mapSize.height = 512;
		light.shadow.camera.near = 100;
		light.shadow.camera.far = 1200;
		light.shadow.camera.left = -1000;
		light.shadow.camera.right = 1000;
		light.shadow.camera.top = 350;
		light.shadow.camera.bottom = -350;
		this.scene.add( light );
	}
}
new Page();
</script>
</html>